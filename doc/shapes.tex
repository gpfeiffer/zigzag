%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  GAP documentation                             Goetz.Pfeiffer@nuigalway.ie
%%
%A  $Id: shapes.tex,v 1.1 2002/11/19 20:48:40 goetz Exp $
%%
%Y  Copyright (C) 2002, Department of Mathematics, NUI, Galway, Ireland.
%%
%%  This file documents the general functions for shapes.
%%
\Chapter{Shapes}

Let $(W,  S)$ be  a finite Coxeter  system.  The  *shape* of a  subset $J
\subseteq S$ is the set of  all conjugates $J^w$ of $J$ under elements $w
\in W$  such that $J^w$ is  again a subset  of $S$.  The name  was chosen
because  this  concept is  a  generalization  of  the *cycle  shape*  for
elements of the symmetric group $S_n$.

The cycle shape of a permutation $\alpha  \in S_n$ is a partition of $n$. 
It indicates the conjugacy class  of elements of $S_n$ that $\alpha$ lies
in.  The  partitions of  $n$ also parameterize  the conjugacy  classes of
parabolic  subgroups of  $S_n$.  The  most important  ones of  those, the
Young subgroups  of $S_n$, are generated by  the subsets of the  set $S =
\{s_1, \dots, s_{n-1}\}$ of standard generators $s_i = (i, i+1)$.

In a general  finite Coxeter group, the concept  of shapes partitions the
subsets of $S$  (by definition), the set of  parabolic subgroups, and the
set of  conjugacy classes of elements  (and so the set  of elements) into
classes.

Shapes are domains, so every set theoretic function for domains is
applicable to them (see "Set Functions for a Shape").

The functions described here are in the file '\"shapes.g\"'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Shape}%
\index{constructor!of a shape}

'Shape( <W>, <J> )'

constructs the shape  of <J> in <W>.  Here <W> is  a finite Coxeter group
of rank $n$ and <J> is a subset of $[1..n]$.

|    gap> W:= CoxeterGroup("E", 6);; 
    gap> Shape(W, [1, 2, 3]);
    Shape( CoxeterGroup("E", 6), [ 1, 2, 3 ] ) |

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Set Functions for a Shape}

All  set theoretic  functions  described in  chapter  "Domains" are  also
applicable  to  shapes.   This  section  describes  which  functions  are
implemented  specially  for shapes.   Functions  not  mentioned here  are
handled by  the default methods  described in the respective  sections of
chapter "Domains".

'Elements( <shape> )'
\index{Elements!for a Shape}

returns the set  of elements of a  shape, that is the sorted  list of all
the conjugates of a subset $J$ of $S$.

|    gap> W:= CoxeterGroup("A", 3);;
    gap> Elements(Shape(W, [2]));
    [ [ 1 ], [ 2 ], [ 3 ] ] |

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{ShapeOps.Transversal}

'<shape>.operations.Transversal( <shape> )'

The *transversal*  of the shape of  <J> in <W>  is a list of  elements of
<W>, with the property that the  $i$th element of the list maps <J> under
conjugation to the  $i$th element of the shape.  Note  that <J> needs not
be the first element in the shape.

|    gap> W:= CoxeterGroup("A", 3);;
    gap> sh:= Shape(W, [2]);   
    Shape( CoxeterGroup("A", 3), [ 2 ] )
    gap> Elements(sh);
    [ [ 1 ], [ 2 ], [ 3 ] ]
    gap> sh.operations.Transversal(sh);
    [ ( 1, 8)( 2, 7)( 3, 6)( 4,10)( 9,12), (), 
      ( 1, 6)( 2, 9)( 3, 8)( 5,11)( 7,12) ] |
      
The transversal  of a shape is  constructed whenever the  elements of the
shape are determined (see "Set Functions for a Shape").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{ShapeOps.Edges}

'<shape>.operations.Edges( <shape> )'

The  elements of  a shape  form the  vertices of  a directed  graph.  The
*edges* of a  shape are the edges  of this graph and they  are defined as
follows.  Let $J$ be  an element of the shape and let  $s \in S \setminus
J$.  Let $M =  J \cup \{s\}$ and let $w \in W$  be the longest element of
the parabolic subgroup $W_M$.  Then $J^w$  is a subset of $M$ and thus an
element of  the shape.  In  the graph, this  yields and edge from  $J$ to
$J^w$ with labels $s$ and $w$.  

The function  'Edges' returns all  these edges in  the form of a  list of
lists, with  one list for every  vertex (element $J$ of  the shape).  The
entries in the  list for $J$ correspond to the generators  $s \in S$ with
unbound entries for $s \in J$.  In  the other cases the list element is a
record with components |v| and |w|,  where |v| gives the address of $J^w$
in the list of elements, and where |w| gives the permutation $w$.

|    gap> W:= CoxeterGroup("A", 2);;
    gap> sh:= Shape(W, [1]);;
    gap> sh.operations.Edges(sh);  
    [ [ , rec(
              v := 2,
              w := (1,5)(2,4)(3,6) ) ], [ rec(
              v := 1,
              w := (1,5)(2,4)(3,6) ) ] ] |
              
The edges of  a shape are constructed whenever the  elements of the shape
are determined (see "Set Functions for a Shape").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Shape Records}

Like all  other domains shapes are  represented by records.   While it is
possible to construct  such a record by hand it is  preferable to use the
constructor function 'Shape' (see "Shape").

After such  a record is  created one can add  record components.  But you
may not alter the values of components which are already present.

A shape record has the following category components.

'isDomain': \\
        is always 'true' since a shape is a domain.
        
The  following components are  the identification  components of  a shape
record.

'W': \\
        is the Coxeter group of rank $n$ this shape refers to.

'J': \\
        is the subset of $[1..n]$ that generates this shape.
        
Other components which  contain information about the shape  may be added
automatically over  time.  These  components are better  accessed through
the functions that will create them if not present.

'size': \\
        is the  size of the shape  and can be obtained  from the function
        'Size' (see \"Size\").

'elements': \\
        is the set of elements of  the shape and can be obtained from the
        function 'Elements' (see \"Elements\").

'edges': \\
        is the  set of edges  of the shape  and can be obtained  from the
        function 'ShapeOps.Edges' (see "ShapeOps.Edges").

'transversal': \\
        is  the transversal of  the shape  and can  be obtained  from the
        function 'ShapeOps.Transversal' (see "ShapeOps.Transversal").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Functions for Coxeter Groups using a Shape}

The    functions    'NormalizerShape'    (see   "NormalizerShape")    and
'RelationShape' (see "RelationShape") use  a shape to provide information
about a Coxeter group <W>.  For  the sake of users of Coxeter groups that
are not familiar with shapes, the  arguments passed are <W> and a set <J>
rather than the shape of <J> in <W>.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{NormalizerShape}

'NormalizerShape( <W>, <J> )'

The *normalizer* of a shape is ...

...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{RelationShape}

'RelationShape( <W>, <J> )'

returns the binary  relation induced by the directed  edges on the vertex
set of the graph associated to the shape of <J> in <W> (see \"Relation\").

...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Shapes}

'Shapes( <W> )'

returns  an object  representing the  list of  all shapes  of  the finite
Coxeter group <W>.

...

|    gap> W:= CoxeterGroup("A", 3);;
    gap> Shapes(W);
    Shapes( CoxeterGroup("A", 3) ) |

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Set Functions for Shapes}

All  set theoretic  functions  described in  chapter  "Domains" are  also
applicable to  a shapes object.   This section describes  which functions
are implemented  specially for shapes.  Functions not  mentioned here are
handled by  the default methods  described in the respective  sections of
chapter "Domains".

'Elements( <shapes> )'
\index{Elements!for Shapes}

returns the list of shapes represented by the shapes object.  The shapes
in this list are order as follows: ...

In general, the list returned is not a set !!!

|    gap> lambda:= Shapes(CoxeterGroup("A", 3));
    Shapes( CoxeterGroup("A", 3) )
    gap> Elements(lambda);
    [ [ [  ] ], [ [ 1 ], [ 2 ], [ 3 ] ], [ [ 1, 3 ] ], 
      [ [ 1, 2 ], [ 2, 3 ] ], [ [ 1, 2, 3 ] ] ] |

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Functions for Coxeter Groups using Shapes}

The  functions 'XCharacters' (see  "XCharacters") and  'YCharacters' (see
"YCharacters")  use  the  shapes  of  a  Coxeter  group  <W>  to  provide
information about  <W>.  It seems more  natural to have them  work on the
argument <W> rather than the shapes object.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{XCharacters}

'XCharacters( <W> )'

returns  ...

% |    gap> W:= CoxeterGroup("A", 4);;
%     gap> xch:= XCharacters(W);
%     [ [ 120, 0, 0, 0, 0, 0, 0 ], [ 60, 6, 0, 0, 0, 0, 0 ], 
%       [ 30, 6, 2, 0, 0, 0, 0 ], [ 20, 6, 0, 2, 0, 0, 0 ], 
%       [ 10, 4, 2, 1, 1, 0, 0 ], [ 5, 3, 1, 2, 0, 1, 0 ], 
%       [ 1, 1, 1, 1, 1, 1, 1 ] ]
%     gap> ct:= CharTable(W);;  Unbind(ct.irredinfo);
%     gap> Display(ct, rec(chars:= xch, letter:= "X", powermap:= false,   
%     >                    centralizers:= false));
%     W( A4 )
    
%            11111 2111 221 311 32 41 5
    
%     X.1      120    .   .   .  .  . .
%     X.2       60    6   .   .  .  . .
%     X.3       30    6   2   .  .  . .
%     X.4       20    6   .   2  .  . .
%     X.5       10    4   2   1  1  . .
%     X.6        5    3   1   2  .  1 .
%     X.7        1    1   1   1  1  1 1
% |

|    gap> W:= CoxeterGroup("D", 4);;
    gap> xch:= XCharacters(W);                     
    [ [ 192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], 
      [ 96, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], 
      [ 48, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], 
      [ 48, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0 ], 
      [ 48, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0 ], 
      [ 32, 0, 0, 8, 0, 0, 0, 0, 0, 2, 0, 0, 0 ], 
      [ 24, 4, 0, 6, 0, 2, 4, 4, 0, 0, 0, 0, 0 ], 
      [ 8, 4, 0, 4, 2, 0, 0, 0, 0, 2, 0, 0, 0 ], 
      [ 8, 0, 0, 4, 0, 0, 4, 0, 0, 2, 0, 2, 0 ], 
      [ 8, 0, 0, 4, 0, 0, 0, 4, 0, 2, 0, 0, 2 ], 
      [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ]
    gap> ct:= CharTable(W);;  Unbind(ct.irredinfo);
    gap> Display(ct, rec(chars:= xch, letter:= "X", powermap:= false,        
    >                    centralizers:= false));
    W( D4 )
    
            1111. 11.11 .1111 211. 1.21 2.11 22.+ 22.- .22 31. .31 4.+ 4.-
    
    X.1       192     .     .    .    .    .    .    .   .   .   .   .   .
    X.2        96     .     .    8    .    .    .    .   .   .   .   .   .
    X.3        48     8     .    8    .    .    .    .   .   .   .   .   .
    X.4        48     .     .    8    .    .    8    .   .   .   .   .   .
    X.5        48     .     .    8    .    .    .    8   .   .   .   .   .
    X.6        32     .     .    8    .    .    .    .   .   2   .   .   .
    X.7        24     4     .    6    .    2    4    4   .   .   .   .   .
    X.8         8     4     .    4    2    .    .    .   .   2   .   .   .
    X.9         8     .     .    4    .    .    4    .   .   2   .   2   .
    X.10        8     .     .    4    .    .    .    4   .   2   .   .   2
    X.11        1     1     1    1    1    1    1    1   1   1   1   1   1
|


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{YCharacters}

'YCharacters( <W> )'

returns  ...

|    gap> W:= CoxeterGroup("D", 4);;
    gap> ych:= YCharacters(W);
    [ [ 1, 1, 1, -1, -1, -1, 1, 1, 1, 1, 1, -1, -1 ], 
      [ 7, -1, -1, -3, 1, 1, -1, 3, -1, 1, -1, 1, -1 ], 
      [ 7, -1, -1, -3, 1, 1, 3, -1, -1, 1, -1, -1, 1 ], 
      [ 23, 3, -1, -5, 1, -1, 3, 3, -1, -1, -1, 1, 1 ], 
      [ 7, 3, -1, -3, -1, 1, -1, -1, -1, 1, -1, 1, 1 ], 
      [ 17, 1, 1, -1, -1, -1, -3, -3, 1, -1, 1, 1, 1 ], 
      [ 17, -3, 1, -1, 1, -1, 1, -3, 1, -1, 1, -1, 1 ], 
      [ 17, -3, 1, -1, 1, -1, -3, 1, 1, -1, 1, 1, -1 ], 
      [ 17, -3, 1, 1, -1, 1, -3, 1, 1, -1, 1, -1, 1 ], 
      [ 17, -3, 1, 1, -1, 1, 1, -3, 1, -1, 1, 1, -1 ], 
      [ 17, 1, 1, 1, 1, 1, -3, -3, 1, -1, 1, -1, -1 ], 
      [ 23, 3, -1, 5, -1, 1, 3, 3, -1, -1, -1, -1, -1 ], 
      [ 7, 3, -1, 3, 1, -1, -1, -1, -1, 1, -1, -1, -1 ], 
      [ 7, -1, -1, 3, -1, -1, 3, -1, -1, 1, -1, 1, -1 ], 
      [ 7, -1, -1, 3, -1, -1, -1, 3, -1, 1, -1, -1, 1 ], 
      [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ]
    gap> ct:= CharTable(W);;  Unbind(ct.irredinfo);
    gap> Display(ct, rec(chars:= ych, letter:= "Y", powermap:= false,
    >                    centralizers:= false));
    W( D4 )
    
            1111. 11.11 .1111 211. 1.21 2.11 22.+ 22.- .22 31. .31 4.+ 4.-
    
    Y.1         1     1     1   -1   -1   -1    1    1   1   1   1  -1  -1
    Y.2         7    -1    -1   -3    1    1   -1    3  -1   1  -1   1  -1
    Y.3         7    -1    -1   -3    1    1    3   -1  -1   1  -1  -1   1
    Y.4        23     3    -1   -5    1   -1    3    3  -1  -1  -1   1   1
    Y.5         7     3    -1   -3   -1    1   -1   -1  -1   1  -1   1   1
    Y.6        17     1     1   -1   -1   -1   -3   -3   1  -1   1   1   1
    Y.7        17    -3     1   -1    1   -1    1   -3   1  -1   1  -1   1
    Y.8        17    -3     1   -1    1   -1   -3    1   1  -1   1   1  -1
    Y.9        17    -3     1    1   -1    1   -3    1   1  -1   1  -1   1
    Y.10       17    -3     1    1   -1    1    1   -3   1  -1   1   1  -1
    Y.11       17     1     1    1    1    1   -3   -3   1  -1   1  -1  -1
    Y.12       23     3    -1    5   -1    1    3    3  -1  -1  -1  -1  -1
    Y.13        7     3    -1    3    1   -1   -1   -1  -1   1  -1  -1  -1
    Y.14        7    -1    -1    3   -1   -1    3   -1  -1   1  -1   1  -1
    Y.15        7    -1    -1    3   -1   -1   -1    3  -1   1  -1  -1   1
    Y.16        1     1     1    1    1    1    1    1   1   1   1   1   1
|


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E  Emacs . . . . . . . . . . . . . . . . . . . . . . . local emacs variables
%%
%%  Local Variables:
%%  mode:               LaTeX
%%  outline-regexp:     "\\\\Chapter\\|\\\\Section"
%%  fill-column:        73
%%  TeX-master:         "manual"
%%  eval:               (outline-minor-mode)
%%  End:
%%

