<?xml version="1.0" encoding="ISO-8859-1"?>

<!--  ZigZag Documentation
     $Id: zigzag.xml,v 1.18 2006/12/18 09:41:29 goetz Exp $
-->

<!DOCTYPE Book SYSTEM "gapdoc.dtd">

<Book Name="zigzag">
  <TitlePage>
    <Title><Package>ZigZag</Package></Title>
    <Subtitle>A &GAP;3 package for Descent Algebras 
of Finite Coxeter Groups</Subtitle>
    <Version>
Version 0.70
    </Version>
    <Author>
Götz Pfeiffer
<Email>goetz.pfeiffer@nuigalway.ie</Email>
<Homepage>http://schmidt.nuigalway.ie/zigzag</Homepage>
</Author>
    <Copyright>
&copyright; 2006 Götz Pfeiffer, 
Department of Mathematics, NUI, Galway, Ireland
</Copyright>
  </TitlePage>

  <TableOfContents/>

  <Body>

<#Include SYSTEM "introduc.xml">

<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-->
<Chapter>
<Heading>Methods.</Heading>

<#Include Label="Intro:Methods">

<Section>
<Heading>More about Methods.</Heading>

For many methods, \GAP\ provides a <E>global</E> function with the same
name, which will eventually calls the method in the operations record.
If such a global function does not exist, I can always write one myself.
But this might get in the way of other packages which might want to use
this global function for a different purpose.  And if such a global
function does already exist, its use of parameters might not fit my
purpose.  Here we provide an alternative way of accessing an installed
method without the help of a corresponding global function.  Instead we
define a single function <Ref Func="Call"/> which takes an object and a method
as arguments and then applies the method to the object.
Moreover, we define a function <Ref Func="ApplyMethod"/> which in addition
takes other arguments that are passed on to the method call. <P/>

For example, the global function <C>Length</C> is defined in such a
way that it does not search for a method <C>Length</C> when applied to
an object.  To install and use such a method, one can proceed as
follows.  For the purpose of illustration we define <C>Partition</C>
objects and install a <C>Length</C> method for them.  Moreover, we
install a method <C>At</C> to access the part of a <C>Partition</C> at
a given position.

<Listing Type="From methods.g"><![CDATA[
PartitionOps:= rec();

Partition:= function(parts)
    return rec(parts:= parts, operations:= PartitionOps);
end;

PartitionOps.Print:= function(this)
    Print("Partition( ", this.parts, " )");
end;

PartitionOps.Length:= function(this)
    return Length(this.parts);
end;

PartitionOps.At:= function(this, i)
    return this.parts[i];
end;]]>
</Listing>
As a convention the parameter  name <A>this</A> is used for the object
on behalf of which the method is invoked. The same name is used in the
Java programming language, where it  needs not be listed explicitly as
a parameter.<P/>


	When a  <C>Partition</C> object  has been created,  the global
	<C>Length</C>  function  cannot  be  applied to  it, 
and positional selection with square brackets does not work.  But  the
	mechanism implemented here is available, see the examples below.

<Example>
gap> p:= Partition([4, 3, 3, 1]);
Partition( [ 4, 3, 3, 1 ] )
gap> Length(p);
Error, Length: &lt;list&gt; must be a list
gap> p[2];
Error, List Element: &lt;list&gt; must be a list
</Example>
</Section>


<Section>
<Heading>Method Calls.</Heading>

<#Include Label="Call">

<#Include Label="ApplyMethod">

</Section>
</Chapter>

<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-->
<Chapter>
<Heading>Iterators.</Heading>

<#Include Label="Intro:Iterators">

<Section>
<Heading>Default Iterators.</Heading>

<#Include Label="IteratorSet">

<#Include Label="Iterator">

<#Include Label="Iterator(domain)">

</Section>

<Section>
<Heading>Examples of Iterators.</Heading>
The iterator for sets is implemented as follows.
<Listing Type="From iterator.g"><![CDATA[
IteratorSet:= function(set)
    local itr, i;
    
    # initialize.
    i:=0;  itr:= rec();
    
    # the hasNext() function.
    itr.hasNext:= function() 
        return i < Length(set);
    end;
    
    # the next() function.
    itr.next:= function() 
        i:= i + 1;
        return set[i]; 
    end;
    
    return itr;
end;]]>
</Listing>
Here the state of the iterator, i.e., the set <A>set</A>that it is looping
over and the current position <C>i</C> in the set are parameters
and local variables of the function <Ref Func="IteratorSet"/>.   As such they
are not accessible (not even for debugging) from the outside when
the iterator methods <C>hasNext()</C> and <C>next()</C> are executed.
This way of data hiding prevents the state variables from being accidentally
corrupted.<P/>

Alternatively, the state can be stored in form of fields of the iterator record.
<Listing><![CDATA[
IteratorSet:= function(set)
    local itr;
    
    # initialize.
    itr:= rec(set:= set, i:= 0);
    
    # the hasNext() function.
    itr.hasNext:= function() 
        return itr.i < Length(itr.set);
    end;
    
    # the next() function.
    itr.next:= function() 
        itr.i:= itr.i + 1;
        return itr.set[itr.i]; 
    end;
    
    return itr;
end;]]>
</Listing>
This might be considered unsafe by some.  <P/>

As further example, here is an iterator for ranges.
<Listing><![CDATA[
IteratorRange:= function(range)
    local   itr,  len,  more,  lo,  hi,  inc,  val;
    
    # check argument.
    if not IsRange(range) then Error("<range> must be a range"); fi;
    
    # initialize.
    itr:= rec();  len:= Length(range);  more:= len > 0;
    if more then
        lo:= range[1];  hi:= range[len]; 
        if len > 1 then inc:= range[2]-lo; else inc:= 0; fi;
    fi;
    
    # the hasNext() function.
    itr.hasNext:= function() return more; end;
    
    # the next() function.
    itr.next:= function() 
        local val;
        more:= lo <> hi;  val:= lo;  lo:= lo + inc;
        return val; 
    end;
    
    return itr;
end;]]>
</Listing>
There  is probably  no need  for such  a type  of iterator,  since the
<K>for</K> loop does  a perfect job of looping  over ranges.  However,
this is how I would write it.

<Subsection>
<Heading>Exercise.</Heading>
Write a function that produces iterators for permutation groups.
</Subsection>

</Section>

</Chapter>

<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-->
<Chapter>
<Heading>Tree Walking.</Heading>

<#Include Label="Intro:Walker">

<Section>
<Heading>Binomial Trees, for Example.</Heading>

	The     <E>binomial    tree</E><Index>binomial    tree</Index>
	<M>T_n</M> is defined recursively as a single vertex if <M>n =
	0</M>,  and as  a  root vertex  with  children <M>T_0,  \dots,
	T_{n-1}</M>, if <M>n > 0</M>.  For the purpose of illustrating
	the  functions  in this  file,  we  can  define binomial  tree
	objects as follows.
<Listing Type="From walker.g"><![CDATA[
BinomialTreeOps:= rec();

BinomialTree:= n -> rec(n:= n, operations:= BinomialTreeOps);

BinomialTreeOps.Children:= function(this)
    return List([0..this.n-1], BinomialTree);
end;

BinomialTreeOps.Print:= function(this)
    Print(this.n);
end;]]>
</Listing>
	In this way, the binomial tree <M>T_n</M> prints itself simply
	as the integer <M>n</M>.
<Example>
gap> BinomialTree(5);
5
gap> Call(last, "Children");
[ 0, 1, 2, 3, 4 ]
</Example>

	With a suitable <C>Display</C> operation, a binomial tree can be 
displayed in a tree-like fashion.
<Listing Type="From walker.g"><![CDATA[
BinomialTreeOps.indent:= 0;

BinomialTreeOps.Display:= function(this, dummy)   
    local  c;
    
    if this.n > 0 then
        for c in [1..BinomialTreeOps.indent] do
            Print(" ");
        od;
    fi;
    Print("-", this.n);
    if this.n = 0 then
        Print("\n");
    fi;
    
    BinomialTreeOps.indent:= BinomialTreeOps.indent + 2;
    for c in Call(this, "Children") do
        Display(c);
    od;
    BinomialTreeOps.indent:= BinomialTreeOps.indent - 2;
end;]]>
</Listing>
	Given such a recursive <C>Display</C> routine, the
	binomial tree <M>T_4</M> is displayed as follows.
<Example>
gap> Display(BinomialTree(4));
-4-0
  -1-0
  -2-0
    -1-0
  -3-0
    -1-0
    -2-0
      -1-0
</Example>
We will use this tree in the examples of the following sections.

</Section>

<Section>
<Heading>Breadth First Serach.</Heading>

<#Include Label="BreadthFirst">

<#Include Label="IteratorBreadthFirst">

</Section>

<Section>
<Heading>Depth First Search.</Heading>

<#Include Label="PreOrder">

<#Include Label="NrPreOrder">

<#Include Label="IteratorPreOrder">

<#Include Label="PreOrderProperty">

<#Include Label="NrPreOrderProperty">

<#Include Label="PostOrder">

<#Include Label="PostOrderProperty">

<#Include Label="NrPostOrderProperty">

<Subsection>
<Heading>Exercise.</Heading>
 Write a function
	  <C>IteratorPostOrder</C>that produces an iterator for a tree
	  such that its <C>next()</C> method returns the vertices of
	  the tree in post order.
</Subsection>

</Section>

</Chapter>

<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-->
<Chapter>
<Heading>Subsets of Finite Coxeter Groups.</Heading>

<#Include Label="Intro:Subsets">

<Section>
<Heading>Prefix Sets.</Heading>

<#Include Label="Prefixes">

<#Include Label="IsPrefixes">

<#Include Label="Elements(prefixes)">

<#Include Label="Iterator(prefixes)">

<#Include Label="Edges(prefixes)">

<#Include Label="Relation(prefixes)">

</Section>

<Section>
<Heading>Weak Intervals.</Heading>

<#Include Label="WeakInterval">

<#Include Label="IsWeakInterval">

</Section>

<Section>
<Heading>Parabolic Transversals.</Heading>

<#Include Label="ParabolicTransversal">

<#Include Label="IsParabolicTransversal">

</Section>

<Section>
<Heading>Descent Classes.</Heading>

<#Include Label="DescentClass">

<#Include Label="IsDescentClass">

<#Include Label="DescentClasses">

</Section>

<Section>
<Heading>Left Parabolic Transversals.</Heading>

<#Include Label="LeftParabolicTransversal">

<#Include Label="IsLeftParabolicTransversal">

</Section>

<Section>
<Heading>Double Parabolic Transversals.</Heading>

<#Include Label="DoubleParabolicTransversal">

<#Include Label="IsDoubleParabolicTransversal">

</Section>

<Section>
<Heading>XJKLs.</Heading>

<#Include Label="XJKL">

<#Include Label="IsXJKL">

</Section>

</Chapter>

<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-->
<Chapter>
<Heading>Shapes.</Heading>

Let <M>(W, S)</M>  be a finite Coxeter system.   The <E>shape</E> 
      <Index>shape</Index> of a
subset <M>J \subseteq S</M> is the set of all conjugates <M>J^w</M> of
<M>J</M> under elements <M>w \in W</M> such that <M>J^w</M> is again a
subset of  <M>S</M>.  The  name was chosen  because this concept  is a
generalization of the <E>cycle shape</E> for elements of the symmetric
group <M>S_n</M>.<P/>

The cycle shape of a  permutation <M>\alpha \in S_n</M> is a partition
of  <M>n</M>.   It  indicates  the  conjugacy  class  of  elements  of
<M>S_n</M>  that <M>\alpha</M>  lies in.   The partitions  of <M>n</M>
also  parameterize the  conjugacy  classes of  parabolic subgroups  of
<M>S_n</M>.  The most important ones  of those, the Young subgroups of
<M>S_n</M>,  are generated by  the subsets  of the  set <M>S  = \{s_1,
\dots, s_{n-1}\}</M> of standard generators <M>s_i = (i, i+1)</M>.<P/>

In a  general finite Coxeter  group, the concept of  shapes partitions
the  subsets  of  <M>S</M>  (by  definition),  the  set  of  parabolic
subgroups, and  the set of conjugacy  classes of elements  (and so the
set of elements) into classes.<P/>

Shapes are domains,  so every set theoretic function  for a domain can
be     applied      to     a     shape      (see     section&nbsp;<Ref
Label="Sect:ShapesAsSets"/>).<P/>

The functions described here are in the file <F>shapes.g</F>.

<Section><Heading>Shape Constructors and Methods.</Heading>

In this section I describe the functions that construct shapes
and work on shapes.

<#Include Label="Shape">

<#Include Label="IsShape">

<#Include Label="Rank(shape)">

</Section>

<Section Label="Sect:ShapesAsSets">
<Heading>Set Methods for Shapes.</Heading>

Shapes are domains and therefore all set theoretic functions described
in  chapter "Domains"  are also  applicable to  shapes.   This section
describes  which  functions  are  implemented  specially  for  shapes.
Functions  not  mentioned here  are  handled  by  the default  methods
described in the respective sections of chapter "Domains".

More precisely, every shape has as its operations record
<C>ShapeOps</C> which inherits from <C>DomainOps</C>
and overrides the methods below to make it work or to provide 
more efficient implementations.

<#Include Label="Elements(shape)">

<#Include Label="Representative(shape)">

</Section>

<Section Label="Sect:ShapeRecords">
<Heading>Shape Records.</Heading>
Like all  other domains shapes are  represented by records.   While it is
possible to construct  such a record by hand it is  preferable to use the
constructor function <Ref Func="Shape"/>).<P/>

After such a record is created you can add more components.  But you
should not alter the values of components which are already
present.<P/>

A shape record has the following <E>category components</E>.
<List>
<Mark>
  <C>isDomain</C>:
</Mark>
<Item>
  is always <K>true</K> since a shape is a domain.
</Item>
<Mark>
  <C>isShape</C>:
</Mark>
<Item>
  is always <K>true</K>.
</Item>
</List>
        
The following components are the <E>identification</E> components of a
shape record.
<List>
<Mark>
  <C>W</C>:
</Mark>
<Item>
  is the Coxeter group of rank <M>n</M> this shape refers to.
</Item>
<Mark>
  <C>J</C>:
</Mark>
<Item>
  is the subset of <C>[1..n]</C> that generates this shape.
</Item>
</List>
        
Other components which  contain information about the shape  may be added
automatically over  time.  These  components are better  accessed through
the functions that will create them if not present.
<List>
<Mark><C>size</C>:</Mark>
<Item> is the  size of the shape  and can be obtained  through the method
<C>Size</C>.
</Item>
<Mark><C>elements</C>:</Mark>
<Item> is the set of elements of  the shape and can be obtained from the
        method <Ref Meth="Elements" Label="for shapes"/>.
</Item>
<Mark><C>edges</C>:</Mark>
<Item> is the  set of edges  of the shape  and can be obtained through the
        method <Ref Meth="ShapeOps.Edges"/>.
</Item>
<Mark><C>transversal</C>:</Mark>
<Item> is  the transversal of  the shape  and can  be obtained  through the
        method <Ref Meth="ShapeOps.Transversal"/>.
</Item>
</List>

<#Include Label="Edges(shape)">

<#Include Label="Transversal(shape)">

</Section>

<Section Label="Sect:ShapesAsShapes">
<Heading>Further Methods for Shapes.</Heading>

In this section I describe some methods for shapes.

<#Include Label="Relation(shape)">

<#Include Label="Complement(shape)">

<#Include Label="ConjugacyClasses(shape)">

</Section>

<Section Label="Sect:ShapesCoxeterGroup">
<Heading>Shapes and Coxeter Groups.</Heading>

Functions like <Ref Func="XCharacters"/> and <Ref Func="YCharacters"/>
use the shapes of a Coxeter group <M>W</M> to provide information
about <M>W</M>.  In this section I describe these and other functions
for finite Coxeter groups that use shapes.

<#Include Label="Shapes">

<#Include Label="SubsetsShapes">

<#Include Label="ComplementsShapes">

<#Include Label="XCharacters">

<#Include Label="ParabolicTom">

<#Include Label="YCharacters">

</Section>

</Chapter>

<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-->
<Chapter>
<Heading>Arrows.</Heading>

<#Include Label="Intro:Arrows">

<Section>
<Heading>Arrow Multiplication.</Heading>

<#Include Label="ProductArrows">

<#Include Label="ProductArrowList">

<#Include Label="FactorsArrow">

</Section>

<Section>
<Heading>Operation on Arrows.</Heading>

<#Include Label="OnArrows">

<#Include Label="StabilizerArrow">

</Section>

<Section>
<Heading>Difference Operators.</Heading>

<#Include Label="LittleDeltaArrow">

<#Include Label="DeltaArrow">

<#Include Label="ReversedArrow">

</Section>

</Chapter>

<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-->
<Chapter>
<Heading>Bundles aka Arrow Classes.</Heading>

<#Include Label="Intro:Bundles">

<Section>
<Heading>Bundle Objects.</Heading>

<#Include Label="Bundle">

<#Include Label="IsBundle">

</Section>

<Section Label="Sect:BundlesAsSets">
<Heading>Set Methods for Bundles.</Heading>

Bundles are domains and therefore all set theoretic functions described
in  chapter "Domains"  are also  applicable to  bundles.   This section
describes  which  functions  are  implemented  specially  for  bundles.
Functions  not  mentioned here  are  handled  by  the default  methods
described in the respective sections of chapter "Domains".

More precisely, every bundle has as its operations record
<C>BundleOps</C> which inherits from <C>DomainOps</C>
and overrides the methods below to make it work or to provide 
more efficient implementations.

<#Include Label="Elements(bundle)">

<#Include Label="Representative(bundle)">

</Section>



</Chapter>



</Body>
  <Bibliography Databases="zigzag"/>
  <TheIndex/>

</Book>
