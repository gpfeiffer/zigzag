<?xml version="1.0" encoding="ISO-8859-1"?>

<!--  ZigZag Documentation
     $Id: zigzag.xml,v 1.9 2006/05/29 12:59:42 goetz Exp $
-->

<!DOCTYPE Book SYSTEM "gapdoc.dtd">

<Book Name="zigzag">
  <TitlePage>
    <Title><Package>ZigZag</Package></Title>
    <Version>Version 0.18</Version>
    <Author>
Götz Pfeiffer
<Email>goetz.pfeiffer@nuigalway.ie</Email>
<Homepage>http://schmidt.nuigalway.ie/zigzag</Homepage>
</Author>
    <Copyright>
&copyright; 2006 Götz Pfeiffer, 
Department of Mathematics, NUI, Galway, Ireland
</Copyright>
  </TitlePage>

  <TableOfContents/>

  <Body>
<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-->
<Chapter>
<Heading>Methods.</Heading>

<#Include Label="Intro:Methods">

<Section>
<Heading>Method Calls.</Heading>

<#Include Label="Call">

<#Include Label="ApplyMethod">

</Section>
</Chapter>

<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-->
<Chapter>
<Heading>Iterators.</Heading>

<#Include Label="Intro:Iterators">

<Section>
<Heading>Default Iterators.</Heading>

<#Include Label="IteratorSet">

<#Include Label="Iterator">

<#Include Label="Iterator(domain)">

</Section>

<Section>
<Heading>Examples of Iterators.</Heading>
The iterator for sets is implemented as follows.
<Listing Type="From iterator.g"><![CDATA[
IteratorSet:= function(set)
    local itr, i;
    
    # initialize.
    i:=0;  itr:= rec();
    
    # the hasNext() function.
    itr.hasNext:= function() 
        return i < Length(set);
    end;
    
    # the next() function.
    itr.next:= function() 
        i:= i + 1;
        return set[i]; 
    end;
    
    return itr;
end;]]>
</Listing>
Here the state of the iterator, i.e., the set <A>set</A>that it is looping
over and the current position <C>i</C> in the set are parameters
and local variables of the function <Ref Func="IteratorSet"/>.   As such they
are not accessible (not even for debugging) from the outside when
the iterator methods <C>hasNext()</C> and <C>next()</C> are executed.
This way of data hiding prevents the state variables from being accidentally
corrupted.<P/>

Alternatively, the state can be stored in form of fields of the iterator record.
<Listing><![CDATA[
IteratorSet:= function(set)
    local itr;
    
    # initialize.
    itr:= rec(set:= set, i:= 0);
    
    # the hasNext() function.
    itr.hasNext:= function() 
        return itr.i < Length(itr.set);
    end;
    
    # the next() function.
    itr.next:= function() 
        itr.i:= itr.i + 1;
        return itr.set[itr.i]; 
    end;
    
    return itr;
end;]]>
</Listing>
This might be considered unsafe by some.  <P/>

As further example, here is an iterator for ranges.
<Listing><![CDATA[
IteratorRange:= function(range)
    local   itr,  len,  more,  lo,  hi,  inc,  val;
    
    # check argument.
    if not IsRange(range) then Error("<range> must be a range"); fi;
    
    # initialize.
    itr:= rec();  len:= Length(range);  more:= len > 0;
    if more then
        lo:= range[1];  hi:= range[len]; 
        if len > 1 then inc:= range[2]-lo; else inc:= 0; fi;
    fi;
    
    # the hasNext() function.
    itr.hasNext:= function() return more; end;
    
    # the next() function.
    itr.next:= function() 
        local val;
        more:= lo <> hi;  val:= lo;  lo:= lo + inc;
        return val; 
    end;
    
    return itr;
end;]]>
</Listing>
There is probably no need for such a type of iterator, since the <K>for</K> loop
does a perfect job of looping over ranges.  However, this is how I would write it.

<Subsection>
<Heading>Exercise.</Heading>
Write a function that produces iterators for permutation groups.
</Subsection>

</Section>

</Chapter>

<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-->
<Chapter>
<Heading>Shapes.</Heading>

Let <M>(W, S)</M>  be a finite Coxeter system.   The <E>shape</E> of a
subset <M>J \subseteq S</M> is the set of all conjugates <M>J^w</M> of
<M>J</M> under elements <M>w \in W</M> such that <M>J^w</M> is again a
subset of  <M>S</M>.  The  name was chosen  because this concept  is a
generalization of the <E>cycle shape</E> for elements of the symmetric
group <M>S_n</M>.<P/>

The cycle shape of a  permutation <M>\alpha \in S_n</M> is a partition
of  <M>n</M>.   It  indicates  the  conjugacy  class  of  elements  of
<M>S_n</M>  that <M>\alpha</M>  lies in.   The partitions  of <M>n</M>
also  parameterize the  conjugacy  classes of  parabolic subgroups  of
<M>S_n</M>.  The most important ones  of those, the Young subgroups of
<M>S_n</M>,  are generated by  the subsets  of the  set <M>S  = \{s_1,
\dots, s_{n-1}\}</M> of standard generators <M>s_i = (i, i+1)</M>.<P/>

In a  general finite Coxeter  group, the concept of  shapes partitions
the  subsets  of  <M>S</M>  (by  definition),  the  set  of  parabolic
subgroups, and  the set of conjugacy  classes of elements  (and so the
set of elements) into classes.<P/>

Shapes are domains,  so every set theoretic function  for a domain can
be     applied      to     a     shape      (see     section&nbsp;<Ref
Label="Sect:ShapesAsSets"/>).<P/>

The functions described here are in the file <F>shapes.g</F>.

<Section><Heading>Shape Constructors and Methods.</Heading>

In this section I describe the functions that construct shapes
and work on shapes.

<#Include Label="Shape">

<#Include Label="IsShape">

</Section>

<Section Label="Sect:ShapesAsSets">
<Heading>Set Methods for Shapes.</Heading>

Shapes are domains and therefore all set theoretic functions described
in  chapter "Domains"  are also  applicable to  shapes.   This section
describes  which  functions  are  implemented  specially  for  shapes.
Functions  not  mentioned here  are  handled  by  the default  methods
described in the respective sections of chapter "Domains".

More precisely, every shape has as its operations record
<C>ShapeOps</C> which inherits from <C>DomainOps</C>
and overrides the methods below to make it work or to provide 
more efficient implementations.

<#Include Label="Elements(shape)">

<#Include Label="Representative(shape)">

</Section>

<Section Label="Sect:ShapeRecords">
<Heading>Shape Records.</Heading>
Like all  other domains shapes are  represented by records.   While it is
possible to construct  such a record by hand it is  preferable to use the
constructor function <C>Shape</C> (see <Ref Label="Shape"/>).<P/>

After such a record is created you can add more components.  But you
should not alter the values of components which are already
present.<P/>

A shape record has the following <E>category components</E>.
<List>
<Mark>
  <C>isDomain</C>:
</Mark>
<Item>
  is always <K>true</K> since a shape is a domain.
</Item>
<Mark>
  <C>isShape</C>:
</Mark>
<Item>
  is always <K>true</K>.
</Item>
</List>
        
The following components are the <E>identification</E> components of a
shape record.
<List>
<Mark>
  <C>W</C>:
</Mark>
<Item>
  is the Coxeter group of rank <M>n</M> this shape refers to.
</Item>
<Mark>
  <C>J</C>:
</Mark>
<Item>
  is the subset of <C>[1..n]</C> that generates this shape.
</Item>
</List>
        
Other components which  contain information about the shape  may be added
automatically over  time.  These  components are better  accessed through
the functions that will create them if not present.
<List>
<Mark><C>size</C>:</Mark>
<Item> is the  size of the shape  and can be obtained  through the method
<C>Size</C>.
</Item>
<Mark><C>elements</C>:</Mark>
<Item> is the set of elements of  the shape and can be obtained from the
        method <Ref Meth="Elements" Label="for shapes"/>.
</Item>
<Mark><C>edges</C>:</Mark>
<Item> is the  set of edges  of the shape  and can be obtained through the
        method <Ref Meth="ShapeOps.Edges"/>.
</Item>
<Mark><C>transversal</C>:</Mark>
<Item> is  the transversal of  the shape  and can  be obtained  through the
        method <Ref Meth="ShapeOps.Transversal"/>.
</Item>
</List>

<#Include Label="Edges(shape)">

<#Include Label="Transversal(shape)">

</Section>

<Section Label="Sect:ShapesAsShapes">
<Heading>Further Methods for Shapes.</Heading>

In this section I describe some methods for shapes.

<#Include Label="Relation(shape)">

<#Include Label="Complement(shape)">

<#Include Label="ConjugacyClasses(shape)">

</Section>

<Section Label="Sect:ShapesCoxeterGroup">
<Heading>Shapes and Coxeter Groups.</Heading>

In this section I describe new functions for finite Coxeter groups
that use shapes.

<#Include Label="Shapes">

<ManSection>
<Func Name="SubsetsShapes" Arg="shapes"/>
<Returns>
  the list of subsets of <M>S</M> in shape order.
</Returns>
<Description>
Shape order means ...
<Example>
gap> SubsetsShapes(Shapes(CoxeterGroup("A", 3)));
[ [  ], [ 1 ], [ 2 ], [ 3 ], [ 1, 3 ], [ 1, 2 ], [ 2, 3 ], [ 1, 2, 3 ] ]
gap> SubsetsShapes(Shapes(CoxeterGroup("B", 3)));
[ [  ], [ 1 ], [ 2 ], [ 3 ], [ 1, 3 ], [ 2, 3 ], [ 1, 2 ], [ 1, 2, 3 ] ]
</Example>
</Description>
</ManSection>

<#Include Label="XCharacters">

<#Include Label="YCharacters">

</Section>

</Chapter>



</Body>
  <Bibliography Databases="zigzag"/>
  <TheIndex/>

</Book>
